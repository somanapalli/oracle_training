java :

 what is java?
 
    java is oo pl.
	
  platform independent -> wora -> write once run / reuse anywhere.

  

why pl?
 
   ->to develop the software/applications
   
 c,cpp,java,python,.net ..-> s/w
 
 what kind of applications we have?
 
  1.standalone applications/desktop applications
  
  ->calculator,antivirus,acrobatic reader etc...
  
    results are not sharable across the globe.
	
    console based applications.
	
  2.internet based applications
   
      ->google,gmail,facebook... 

    results are sharable across the globe.
	
	
java:
`````
    1995
	
	28 years 
	
      
java is maintaining popularity.

->because of it's charactersitcs/features/buzzwrds

1.platform independent
2.secured
3.robusted
4.simple
...

windows:

c program (.c)

compile: .exe

run: output


windows:
  are you able to execute this program? 
  yes
  
  
  
  c is platform dependent
  
 windows 
  .java
  .class
  
 unix
    yes
	java is platform independent.
	
  one os to other os.

  java program ->programmer responsibility 
  
  steps you have to follow to write the java program?
  
   syntax: rules are given by language vendors
   
   in case of java, sunmicrosystem org, oracle
   
   java is open source 
   
   1.download the java software -> jdk
   2.install the software
   3.select the editor
   4.write the java program 
   5.save the java program (.java)
   6.compile the java program (.class)
   7.run/execute the java program 
  
  
 structure of the java program?
 printf - c language
 java is case sensitive programming languagge
 
 
  java program should starts with by defining the class.
  
    class Test1
	{
	    public static void main(String[] args){
		
		  //logic
		  
		  System.out.println("welcome to java from oracle");
		}
	}
  
  java program execution starts from main() method
 
in c program -> main()
in java program -> public static void main(String[] args){} 
  
  
  command to compile the java program?
  
     javac <filename>.java
	 
	 javac Demo.java
	 
  .java file contains - source code (developer)  -> java compiler 
  
  java compiler will take source code as an input and gives 
  .class file .
  
  
  .class file contains -> byte code 
  
  byte code is not human readable code which can be understandable 
  by jvm(java virtual machine)
  
  who is compiling the java program ? -> java compiler 
  
   java compiler -> predefined java program available in jdk
   
  who is executing the java program?
  
    jvm -> java virtual machine -> 
	jvm will take .class file as an input (byte code) and converts
	machine level code. 
	
command to execute the java program?

     java <classname>
	 
	 java Test1
	 
 how java  is oopl?
 
 if any pl is said to be object oriented, it has to follow some 
 principles.
 
   1.oops principles.
   
   ->omg(object management group)
   
  how many oops principles we have?

    1.inheritance
    2.encapsulation 
    3.abstraction 
    4.polymorphism

how can we achieve in java?

 	by using two concepts
	
	1.class 
	2.object


java program should starts with by defining the class only.

class <classname>
{
     //variables
	 //methods	 
}	
	
 class is a collection of variables and methods into a single unit. 
 that single unit is known as class. 
 
  
  variables:
  
     to store the data we have to provide the names. 
	 
	 syntax:
	   
	    
		  <datatype> <variablename> =<value>;
		  
		  int x = 100;
		  
how many datatypes are available in java?
 8 datatypes
 
 byte,short,int,long  - Integer category
 
 float,double  - float category 
 
 char  ->character category -> to store single character information 
 
 boolean  -> boolean category -> to store logic values (eitehr true or false)
 
 all these are valid
 
 byte b = 100;//1 byte 
 
  -128 to 127
  
  1 byte 
  
 short s = 100;
 
   2 bytes
   
   
 int i = 100;
 4 bytes
 
 long l = 100;
 
 8 bytes
 
 
 every datatype is maintaining two things
 
   1.range
   2.memory size
   
   
 -2^n-1 to 2^n-1 - 1
 n ->no.of bits 
 
 1 byte -> 8 bits
 -2^7 to 2^7 -1
 
 -128 to 127
 
  float f = 4.5f;//valid ->4 bytes
  
  double d = 8.9;//valid   -> 8bytes 
  
  
  
  by default decimal type value is of double type in java
  
 
   char c = 'a';
   
   boolean b = true;
   
   
  all java reserved words must be in lower case
  
  boolean b = false;
  
 methods:
 ````````
 functions -> in c language
 ->to write the logic 
 
 method is also a place, where we are writing the logic, to perform 
 some operations based on the requirement.
 
 
  syntax:
   
       
    method heading-> 
	
	[accessmodier] <returntype> <methodname>([parameters]){
	 
	   //logic -method body
	 }


class is a collection of variables and methods into a single unit.

example:

define one method which displays helloworld message?

  void is representing returntype 
  meaning is not returning any value. 
  
    void displayInfo(){
	   System.out.println("helloworld");
	}

define one method which returns your name?

    String getName(){
	   return "rk";
	}

return value & return type always must be 
compatible with each other.
char ch='a';
String s = "rama";


define one method which takes firstname,lastname as two parameters and 
returns fullname is the combination of firstname and lastname?

   
   String getFullName(String firstName,String lastName){
     return firstName+lastName;
	 
   }
   
   
   getFullName("rk","oracle");
   
     ->rkoracle


define one method which takes two integer values and displays their 
sum?

 void getSum(int x, int y)
 {
   System.out.println("sum is: " +(x+y));
 }
   
   string + anythig is string only 
   
   
  getSum(7,6)
  
    ->sum is: 13
	
	
before i am doing the program on class 
i would like to introduce one ides

 eclipse
 netbeans 
 
   intellij
   myeclipse..


 the code which we are writing in the ide is autocompiled
 we no need to compile the code manually.
 
 we should keep always our userdefined classes or interfaces 
 inside package only .
 it is highly recommended.
 
   inside a single package, how many classes we can define?
     as many as we want
	 
	inner method definition is not possible in java
	
	we can't define the method inside another method.
	but we can call the method from another method(inner method invocation)
	
	whenever we execute the java program, jvm will invoke main method 
	only not our own methods 
	
	who needs to call our own method(s)?
	  programmer.
	  

object:

object is an instance of the class. 
object is real world entity.

human is the class. 

are we occupying any space in the earth?
  
by just defininig the class, memory won't be created 
we are not allowed to store the data.

we have to create the object?
 whenever we create the object, memory will be created for instance properties
 when memory will be created , we are able to store the data which 
 we declared insdie the class.
 
 
 syntax:
 
   <classname> <objectname> = new <classname>();
   
   Student obj = new Student();
   
  
package com.oracle.corejava;
public class Student {
    
    //variables
    
    int stid=100;
    String stname="amulya";
    
    //define one method for displaying above data
    public void displayStudentInfo(){
        
        System.out.println("student id is : " + stid);
        System.out.println("student name is: " + stname);
    
    }
    
    public static void main(String[] args) {
        
        //create the object for Student class
        
       Student obj = new Student();
        
      // System.out.println("student id is : " + obj.stid);
      // System.out.println("student name is: " + obj.stname);
        
        //call the method using object name
        
        obj.displayStudentInfo();
    }
    
}

     private
	 default
	 protected
	 public 
	 
	  using these access modifiers we are able to restrict the 
	  visibiility of the data over the packages.
	  

for a single class, how many objects we can create?
 as many as we want based on the requirement.
 
 1000 students are studying 
 
  assume i want to store 1000 students information?
  
     1000 objects we have to create
	 every object is having one student information .
	 
	 in a single object, can we store multiple student(S) information?

1000
	 
stname
stid
staddresss
collegename


 int x;//non static variable or instance variable
 static String collegeName;//static variable.
 
 for static properties memory will be created only once
 where as for non static properties memory will be created 
as many no.of times based on the object createion .


 when memory will be created for static properties?
 
  whenever class is loaded into main memory (classloader subsystem)-jvm
  only one time. 
 
nonstatic or instance method
 
 void m1(){
    //instance area
 }


 static void m1(){
 // static area


public static void main(String[] args)
{
   //static area
}



instance area:

instance area is an area which belongs to instance or non-static method.


static area: 

static area is an area which belongs to static method 


we can access the static properties in following ways from any area
either static or non-static area 


 1.directly 
 2.using class name 
 3.using object name 
 
 

from static area if we want to access non-static or instance properties 
it is possible by using object name. 


package com.oracle.corejava;
public class Student {
    
    
    //instance variables
    int stid=100;
    String stname="amulya";
    //static variable
    static String collegeName="HCU";
    
    //define one method for displaying above data
    void displayStudentInfo(){
        //instance area
        System.out.println("student id is : " + stid);
        System.out.println("student name is: " + stname);
        System.out.println("college name is: " + collegeName);
        System.out.println("college name using classname:" + Student.collegeName);
        
    }
    
    public static void main(String[] args) {
        //static area
        //create the object for Student class
        
       Student obj = new Student();
        
     System.out.println("student id is : " +obj.stid);
     System.out.println("student name is: " + obj.stname);
     
     //accessing static property from static area 
     
        System.out.println("college name is: " + collegeName);
        System.out.println("college name using classname:" + Student.collegeName);
        System.out.println("college name using object name: " +obj.collegeName);
    }
    
}

    //business logic class
	class Test1{
	
	    int x=100;
		static String y = "Rama";
		
		//instance method
	    public void display()
		{
		      System.out.println(x + " " +y);
  		}
	}
	
	//execution logic class
	class Test2{
	
	  public static void main(String[] args)
	  {
	  //static area
	  
	    Test1 obj = new Test1();
		obj.display();
	  
	  }
	 }
	
	
	
java is object oriented programming language

	1.inheritance
	2.polymorphism
	3.encapsulation 
	4.abstraction 
	
inheritance:
````````````
	inheritance is the process of taking the properties from 
	one class to another class. 
	
	
	class Test1{
	  //logic1 
	}
	
	class Test2{
	  //reuse logic1
	}
	
	if a particular logic is common, instead of redefining the code 
	again and again, what we have to do?
	
	   we have to reuse.
	   
	  duplication of the code will be improved. 

	  memory consumption increased 
	  
	  ->performance will be degraded.
	  
by using inheritance it is possible to reuse the exisiting properties 
from one class to another class. 

	 using one java reserved keyword-> extends keyword-
	 
	
	
	
	whenever we implemented the inheritance concept, parent class 
	properties(variables,methods,..) will be inherited from parent class 
	to child class.
	
	Test1.java:
	````````````
	/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
//parent class
public class Test1 {
    
    
    public void sum(int x, int y){
        System.out.println("sum is : " +(x+y));
    }
}

Test2.java:
```````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */

//try to make this Test2 class as child class
//child class
public class Test2 extends Test1{
    
     public static void main(String[] args) {
        
         Test2 obj = new Test2();
         obj.sum(4,4);
    }
}

note:
using extends keyword, we are able to inherit the properties from 
single class to single class only more than single it is not possible. 
we will get compile time error. 

Test1.java:
````````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
//parent class
public class Test1 {
    
    
    public void sum(int x, int y){
        System.out.println("sum is : " +(x+y));
    }
}

Test2.java:
`````````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */

//try to make this Test2 class as child class
//child class
public class Test2 extends Test1{
    
    public void sub(int x, int y)
    {
       System.out.println("substractio is: " + (x-y)) ;  
    }
     public static void main(String[] args) {
        
         Test2 obj = new Test2();
         obj.sum(4,4);
         obj.sub(7,6);
         
         //Test1 obj = new Test1();
         
         //obj.sum(3,4);
         //obj.sub(6,5);
    }
}


for every java class(predefined or userdefined), there is a super class , root class 

   java.lang.Object 
   
   
class Test1 {

}

class Test2 extends Test1{
}

class Test3 extends Test2{
}
	
	  Object
	System 
	String
	ArrayList 
	   .. 
	Test1,Test2,.. -> Object 
	
	
note:
every java class is an example of inheritance.

example:
`````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
public class Demo {
    
    public static void main(String[] args) {
        
        //create the object for Demo class
        
        Demo obj = new Demo();
        System.out.println(obj.toString());
        
        System.out.println(obj.hashCode());
        
        System.out.println(obj.getClass());
        
    }
    
}


encapsulation:
```````````````
the process of wrapping up of datamembers(variables) and member 
functions(methods)into a single unit. 
this process is called encapuslation 

	ex: class is the best example for an encapsulation.
	
	
rules to make a normal java class as an encapsulated class 

1.should define private variables
2.should define public setters and public getter method(s).

encapsulated classe(s).


	setter method purpose is -> to set the data into an object
	getter method purpose is -> to get the data from an object
	
	default values are there based on the datatype. 
	
	  for all integer category default value is 0
	  
	  for all float category default value is 0.0 
	  
	  for boolean - > false
	  for character -> 
	  
	  for string -> null 
	  
	
	data hiding , 
	 ->security 
	 
	inheritance,encapsulation 
	
	
polymorphism:
`````````````
it is also one of the oop principle. 

 one form into many forms. 
 
  1.method overloading
  2.method overriding
  
  
in java, we have 

  1.compile time polymorphism-method overloading
  2.runtime polymorphism-method overriding
  

  
 method overloading:
 
  method name is same 
  but parameters are different
  
     type,no.of,orderof parameters
	 
m1(int x, String y){}
m1(String x, int y){} -changing the order
m1(float x, float y){}-type of parameters
m1(int x, String y, double z)-no.of parameters

example:
`````````
package com.oracle.polymorphism;

public class Test1 {
	
	public void operation(int x, int y) {
		System.out.println("integer sum is : " +(x+y));
	}

	public void operation(double x, double y) {
		System.out.println("double sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.operation(2.3,4.5);
		obj.operation(6, 7);
	}	
}

above example we can consider as an example for compile time polymorphism
since polymorphism can be resolved at compile time meaning that method 
calling is binded with specific method using reference variable at 
compile time by the compiler.



method overriding:
```````````````````
method name is same (method prototype)including parameters

method body is different from parent class to child class. 

meaning that if you want to achieve method overriding, for sure 
we should maintain inheritance relation in between classe(s).


note
minimum we require 2 classes with parent child relation then only 
we can achieve method overriding.


why should we go for method overriding?

->to achieve the concept of runtime polymorphism.
->if we are not interested to execute existing(parent class) logic



A.java:
`````````
package com.oracle.polymorphism;

public class A {

	public void operation(int x, int y) {
		System.out.println("sum is: " +(x+y));
	}
}

B.java:
`````````
package com.oracle.polymorphism;
//child class cum execution logic class
public class B extends A{

	@Override
	public void operation(int x, int y)
	{
		System.out.println("substraction is: " +(x-y));
	}
	public static void main(String[] args) {
		
		B obj = new B();
		obj.operation(4,3);
	}
}


method overriding - runtime polymorphism.

A.java:
```````
package com.oracle.polymorphism;

public class A {

	public void operation(int x, int y) {
		System.out.println("sum is: " +(x+y));
	}
}


B.java:
````````package com.oracle.polymorphism;
//child class cum execution logic class
public class B extends A{

	@Override
	public void operation(int x, int y)
	{
		System.out.println("substraction is: " +(x-y));
	}
	public static void main(String[] args) {
		
		//B obj = new B();
		//obj.operation(4,3);
		
		//A obj = new A();
		//obj.operation(3, 4);
		//converting child type object to parent type object -upcasting
		 A obj=new B();//Runtime polymorphism
		 obj.operation(4, 3);
		 
		 //Converting parent type object to child type object - downcasting
		 //B obj = (B)new A();
		 //obj.operation(4, 3);
		
	}
}

abstraction:
`````````````
abstraction refers hiding internal implementation details 
and providing functionalites to the end user. 



 sending one message from my mobile to my friend mobile. 
 we are not focusing on how object can provide the service. 
 we are just focusing on what that object can provide?
 
 
-abstract class
-interface

abstract class:
````````````````

if a class contains any undefined method, then it is mandatory 
to make that class as an abstract class otherwise we will get 
compile time error. 

 abstract class Test1{
    abstract void sum(int x, int y);//declare the method
 }

we are not allowed to create the object for an abstract class. 

if any property is common , make that as an abstract and define 
with differnt logics in different classes based on the requirement.

for a single abstract class, how many implementation classes we can define?

based on the requirement, as many as we want.

from one implementation class to anotehr class implementation class 
logic is going to be different.


 Test1.java:
`````````````
package com.oracle.abstraction;

public abstract class Test1 {
	
	
	public abstract void operation(int x, int y);

}


Test2.java:
```````````
package com.oracle.abstraction;

//implementation class 
public class Test2 extends Test1 {

	@Override
	public void operation(int x, int y) {
		
		System.out.println("sum logic :" +(x+y));

	}

}

Test3.java:
````````````
package com.oracle.abstraction;

//implementation class
public class Test3 extends Test1 {

	@Override
	public void operation(int x, int y) {
		System.out.println("division is: " +(x/y));
	}

}

Test.java:
````````````
package com.oracle.abstraction;

//execution logic class
public class Test {

	public static void main(String[] args) {
		
		//create an object of Test1 class
		//runtime polymorphism - upcasting
		//Test1 obj = new Test2();
		Test1 obj = new Test3();
		obj.operation(4, 2);
		
	}
}

using abstract class, we can achieve the abstraction in between 
0 to 100%
 
  to achieve 100% abstraction we will go for 
  interface(s).
  
interface:
``````````
  syntax:
   
       interface <interfacename>
	   {
	        //constants
			//abstract methods

	   }
	  
	  
	ex:
  
        interface i1{
              void m1();
         }

by default interface methods are public abstract , we no need 
to write explicitly like abstract classe(s).
by default interface variables are public static final.

can we create the object for interface:

 i1 obj = new i1();
 obj.m1();
	
creating the object for an interface is nothing but creating the object
for it's implementation class. 

 
by using implements keyword, we are allowed to bring the interface 
properties to the implementation class.


Bank.java:
```````````
package com.oracle.abstraction;

public interface Bank {
	
	double getRateOfInterest();

}

package com.oracle.abstraction;

public class Icici implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5.5;
	}

}

package com.oracle.abstraction;

public class CityBank implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

package com.oracle.abstraction;

public class Test4 {
	
	public static void main(String[] args) {
		
		//Bank obj = new Icici();
		
		//System.out.println("icici bank rate of interst is: " + obj.getRateOfInterest());
		
        Bank obj = new CityBank();
		
		System.out.println("City bank rate of interst is: " + obj.getRateOfInterest());
	}

}


Access modifiers:
`````````````````

private 
default is not a java keyword
protected
public

 int x; //default variable
 
purpose: these are used to control the visibiility of the data over 
the packages.

private properties we are allowed to access only with in the class

package com.oracle.accessmodifiers;

public class Test1 {
	
	private int x=100;
	
	private void display() {
		System.out.println(x);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		System.out.println(obj.x);
		obj.display();
	}

}
package com.oracle.accessmodifiers;

public class Test2  {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		//obj.x;
		//obj.display();
	}
}

default:
with in the package, from any class we are allowed to access 
default properties

but from other package any class, we are not allowed to acecss the 
default properties.

protected:
with in the package we can access 
otehr package independent class - we cannot access
other package sub class or child class - we can acecss 

public:
there is no restriction from any package any class we are allowed 
to acess the public property 

universal access modifier


exception handling:
```````````````````
exception:

  in general , while we are writing the code, we may get errors 
  
    1. at compile time - because if you are making any mistakes 
	                     syntactically 
						 
	compiletime errors 
	
	runtime erros(exceptions):
	
	2.errors which occurs at runtime meaning that during execution 
	  of the java program.
	  
	  
	why are we getting these exceptions?
	
	  because of logical errors
	  
	  division of two numbers
	  
	  enter firstnuber: 4
	  enter second number: 0
	  
	  division: java.lang.ArithmeticException:/by zero
	  
	  atm machine 
	  
	    enter amount: 4000
		
		4000
		
		insufficient funds, please check your account

		
		

if you pass any invalid data, jvm couldn't process 
in return we will get runtime errors(Exceptions)

drawbacks if we get any exceptions?
1.abnormal termination 
2.we will get system error messages which are not understandable by 
  end user even which is not recommended.
  
exception handling:
```````````````````
as a programmer we should handle that exception.
 
 1.we can escape from abnormal termination meaning that 
   able to achieve normal flow of exceution. 
   
   
 2.instead of getting system error messages we can provide user 
 friendly messages which can be understandable by every end user.
 
 
 how can we handle the exceptions?

  using 5 java reserved keywords


 1.try 
 2.catch 
 3.finally 
 4.throws
 5.throw
 

try block:
`````````````
try block is used to keep the problematic statements which causes 
problems at runtime.

syntax:
  try
  {
    //problematic statements
  }


catch:
``````
catch block is used to catch the exception and provides user friendly 
message.

syntax:

  catch(exceptionclassname <referenevariablename>)
  {
    //user friendly message
  }

example:
`````````
package com.oracle.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		int x =100,y=0;
		try {
		int z = x/y;
		
		System.out.println("division is: " +z);
		}
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */


once control comes from try block to catch block, it will never go back 
to the try block.

for a single try block, how many catch blocks we can define?
 as many as we want based on the requirement.
 
 


in java, who is the parent class for every class in java?

   java.lang.Object
   
   
   for all these exception classes, who is acting as the 
   super class?
   
   

class ArithmeticException extends RuntimeException extends Exception 
extends Throwable extends Object
{
}

FileNotFoundException is the checked exception 

class FileNotFoundException extends Exception extends Throwable 
extends Object{
}

while we are handling the exception , the order always from 
child to parent (specific to general ) not from parent to child 
(general to specific)

example:
`````````
package com.oracle.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		
		Scanner s =new Scanner(System.in);
		
		try {
			
			System.out.println("enter the first number");
			int fno = s.nextInt();
			System.out.println("enter the second number");
			int sno = s.nextInt();
			
			int division = fno/sno;
			
		    System.out.println("division is : " + division );
		}
		
		
		catch(RuntimeException re) {
			System.out.println(re);
		}
//		catch(ArithmeticException ae)
//		{
//			System.out.println("don't enter zero as a denominator");
//		}
//		
//		catch(InputMismatchException im)
//		{
//			System.out.println("please pass only numeric values");
//		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */

try-keep the problematic statments
catch -catch the exception and provides ufm

finally block
 -finally block is used to keep closing related logic 
 -like db connetion closing logic, file closing logic etc.. 
 -once we keep any logic inside the finally block, that logic will be 
  executed everytime whether in positive scenario and negative scenario.
 
example:
`````````
package com.oracle.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		
		Scanner s =new Scanner(System.in);
		
		try {
			
			System.out.println("enter the first number");
			int fno = s.nextInt();
			System.out.println("enter the second number");
			int sno = s.nextInt();
			
			int division = fno/sno;
			
		    System.out.println("division is : " + division );
		}
		
		
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		catch(InputMismatchException im)
		{
			System.out.println("please pass only numeric values");
		}
		
		finally {
			
			System.out.println("finally block executed always");
		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */


throws :
````````
throws is a java reserved keyword which gives an 
indication to the calling 
function to keep the called function under try and 
catch block.

package com.oracle.exceptions;
//called program 
public class Test2 {

	//called method
	public void division() throws ArithmeticException
	{
		int x=100,y=0;
		System.out.println("division is: " +x/y);
	}
}


package com.oracle.exceptions;
//calling program
public class Test3 {
	//calling method
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("passed 0 as denominator");
		}
	}

}


throw:
```````
throw is a java reserved keyword, 

purpose: to throw an exception explicitly.

->throwing is nothging but creating an object 

 0 as denominator -> ArithmeticException can be thrown by jvm 
 
 
we are not throwing predefined exceptions using throw keyword.'
we are throwing our own exceptions using throw keyword.

syntax:

  try{
  throw new <exceptionclassname>();
  }
  catch(Exceptionclassname <referencevariable>){
    //user friendly message
  }
  

ecommerce website

  checking the product whether my product is valid or not 
  based on the product weight.
  
    if my product weight is greather than 100kgs then product is valid
	else InvalidProductException 
	
Test4.java:
```````````
package com.oracle.exceptions;

public class Test4 {
	
	
	public void checkProduct(int weight)
	{
		
		if(weight> 100)
		{
			System.out.println("product is valid");
		}
		else 
		{
			try {
			throw new InvalidProductException("check product weight");
			}
			catch(InvalidProductException ip)
			{
				System.out.println(ip);
			}
		}
	}
	
	
	//mainmethod
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
package com.oracle.exceptions;

public class InvalidProductException extends Throwable{

	
	public InvalidProductException(String message)
	{
		super(message);
	}
}


super :
``````
super is the java reserve keyword to refer parent class properties 
from the child class context when both are same.

 super at method level. -> referning super class method from child 
 class context.
 
 
super at constructor level.

constructor:

constructor is a special member method which is used to initialize 
the object. 


 without constructor:
 
 package com.oracle.constructors;

public class Test1 {

	int x;
	String y;
	public void assignValues()
	{
		x=100;
		y="rk";
	}
	public void display()
	{
		System.out.println(x + " " + y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.assignValues();
		obj.display();
		
	}
}
rules:

constructor name and classname must be same 
constructor should not return anything even void also.
constructor should not be static.

example:
`````````
package com.oracle.constructors;

public class Test1 {

	int x;
	String y;

	/*
	 * public void assignValues() { x=100; y="rk"; }
	 */
	public Test1()
	{
		x=100;
		y="rk";
	}
	
	public void display()
	{
		System.out.println(x + " " + y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		
		obj.display();
		
	}
}

types of constructors:

 default constructor
 parameterized constructor
 

super() -> used to invoke parent class default constructor 

super(...) -> used to invoke parent class parameterized constructor


system defined default constructor example:
````````````````````````````````````````````
package com.oracle.constructors;

public class Test2 {
	
	int x;
	String y;

	/*
	 * public Test2() { x=0; y=null; }
	 */
	public void display()
	{
		System.out.println(x + " "  +y);
	}
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		obj.display();
		
	}

}

collection framework :
```````````````````````


   int a = 100;
   
     int b = 200;
	 
	 1 crore values -> 1 variable 
	 
it is possible by declaring a variable as an array.

	int x[]={100,200,300,400,500};
	
	
	whenever we store the values inside an array, it is getting stored
	based on the index. 
	index value always starts from 0th location.
	length represents no.of elemens resides in that array
	
	x.length = 5
	
	if length is 5 , maximum index is 4
	
	if length is n, maximum index is (n-1) 
	beause index starts from 0th location.
	
	
sop(x[0])


 int x[]={100,200,300,400,"rama"};
 
 
using arrays, we can store only homogenious type of data, not 
heterogenious data. 

in arrays, for every operation we have to write the logic 
manually.

arrays are not following standard ds.

arrays size is fixed in nature ,we can't increase or decrease the 
size of an array at runtime. 


int x[]={100,200,300,400,500};
	
	

x[5]=600;

to overcome these drawbacks, we have one concept i.e 

Collection framework in java:
````````````````````````````

List interface:
`````````````````
->it allows both homogenious and heterogenious objects

->insertion order is preserved 

->duplicate objects are allowed

->null insertion is possible. 

 ArrayList
 LinkedList
 
  List l = new ArrayList();
  List l = new LinkedList();
  
 
from jdk1.5 version onwards, eventhough we are passing primitive type 
values internally it gets converted into object types. 
and viceversa.

  autoboxing 
  & autounboxing
  
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List
		
		List l = new ArrayList();
		
		l.add(Integer.valueOf(100));
		l.add(new String("rk"));
		l.add(Float.valueOf(2.3f));
		
		l.add(Integer.valueOf(100));
		
		l.add(null);
		
		l.add(67);
		
	
		for(int i=0;i<l.size();i++) {
			System.out.println(l.get(i));
		}
		
		System.out.println("==================");
		for(Object o:l)
		{
			System.out.println(o);
		}
		
	}

}
  
example:
``````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List
		
		List l = new ArrayList();
		
		//System.out.println(l.getClass().getName());
		
		
		for(int i=1;i<=10;i++)
		{
			l.add(i);
		}
		
		for(Object o: l)
		{
			//Parent to Child type casting -down casting
			Integer x = (Integer)o;
			
			if(x%2==0)
			{
				System.out.println(x);
			}
		}
		
	}

}

using generics :
``````````````````
1.explicit type casting is not required 
2.we will get compile time errors rather than runtime errors which are 
far better .

   package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List with generi
		
		List<Integer> l = new ArrayList<>();
		
		//System.out.println(l.getClass().getName());
		
		
		for(int i=1;i<=10;i++)
		{
			l.add(i);
		}
		
		//l.add("rama");
		
		for(Integer o: l)
		{
		  if(o%2==0)
			{
				System.out.println(o);
			}
		}
		
		
		
		
	}

}


package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List with generi
		
		List<Employee> l = new ArrayList<>();
		
		l.add(new Employee(100,"Rama"));
		l.add(new Employee(200,"sreeyansh"));
		
		l.add(new Employee(300,"amulya"));
		l.add(new Employee(400,"vedanth"));
		
		
		for(Employee e:l)
		{
			if(e.getEmpname().startsWith("a"))
			{
				System.out.println(e.getEmpid() + " " +e.getEmpname());
			}
		}
		
	}

}

if our frequet operation is insertin /deleteion /updation then 
we will go for LinkedList because internally it follows doublylinkedlist 
algorithm 

whereas if our frequent operation is retreival then we can go for 
ArrayList because ArrayList which implements from RandomAccess 


example:
``````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test2 {

	
	public static void main(String[] args) {
		
		//create the object for List interface
		
		List l = new ArrayList();
		
		l.add(12);
		l.add(null);
		l.add(34);
		l.add(5);
		l.add("rama");
		l.add(true);
		
		System.out.println("before removing" + l);
		
		l.remove(5);
		
		System.out.println("after removing"  + l);
		
		l.remove(new Integer(34));
		
		System.out.println(l);
		
		System.out.println("size is : " + l.size());
		
		
		System.out.println("is empty ? " + l.isEmpty());
		
		System.out.println(l.contains("rama"));
	   
	    System.out.println("3rd index element is : " + l.get(3));
		
	    l.clear();
	    
	    System.out.println("size is after clearning: " + l.size());
		
	    System.out.println(l);
	}
}


Set
  HashSet
  LinkedHashSet
  
SortedSet
  TreeSet

Queue 


 Map 
 SortedMap
 
   HashMap,
   LinkedHashMap
   TreeMap



Set
  HashSet
  LinkedHashSet


Set :

  to group all the objects as a single entity 
  it allows both homogenious and heterogenious objects 
  insertion order is not preserved.
  duplicates are not allowed 
  null insertion is possible but only for one time. 
  
     HashSet
	 LinkedHashSet 
  

class HashSet implements Set extends Collection extends Iterable
{
}

example:
`````````
package com.oracle.cfw;

import java.util.HashSet;

public class Test3 {
	
	public static void main(String[] args) {
		
		//create the object of HashSet
		
		HashSet hs = new HashSet();
		
		hs.add(98);
		hs.add(98);
		hs.add(null);
		hs.add(true);
		hs.add("rk");
		hs.add(null);
		
		
		System.out.println(hs);
	}

}

Test3.java:
```````````
package com.oracle.cfw;

import java.util.HashSet;

public class Test3 {
	
	public static void main(String[] args) {
		
		//create the object of HashSet
		
		HashSet<Employee> hs = new HashSet<>();
		
		hs.add(new Employee(10,"rama"));
		hs.add(new Employee(23,"vedanth"));
		hs.add(new Employee(87,"riya"));
		hs.add(new Employee(10,"rama"));
		
		System.out.println(hs);
	}

}

Employee.java:
```````````````
package com.oracle.cfw;

public class Employee {

	
	private Integer empid;
	private String empname;
	public Integer getEmpid() {
		return empid;
	}
	public void setEmpid(Integer empid) {
		this.empid = empid;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public Employee(Integer empid, String empname) {
		super();
		this.empid = empid;
		this.empname = empname;
	}
	@Override
	public String toString() {
		return empid + " " + empname;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((empid == null) ? 0 : empid.hashCode());
		result = prime * result + ((empname == null) ? 0 : empname.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (empid == null) {
			if (other.empid != null)
				return false;
		} else if (!empid.equals(other.empid))
			return false;
		if (empname == null) {
			if (other.empname != null)
				return false;
		} else if (!empname.equals(other.empname))
			return false;
		return true;
	}
	
	
}


HashSet vs LinkedHashSet:

except insertion order.

in case of LinkedHashSet , insertion order is preserved 



SorteSet:
``````````
SortedSet is an interface

   ->TreeSet
   
 1.it allows only homogenious objects not heterogenious objects
 
   
class TreeSet implements SortedSet extends Set extends Collection extends 
 Iterable
 {
 
 }

example:
``````````
package com.oracle.cfw;

import java.util.TreeSet;

public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for TreeSet
		
		TreeSet<Integer> ts = new TreeSet<>();
		
		ts.add(12);
		ts.add(98);
		ts.add(7);
		ts.add(890);
		ts.add(6);
		
		
		System.out.println(ts);
	}

}


Employee.java:
```````````````
package com.oracle.cfw;

public class Employee implements Comparable<Employee>{

	
	private Integer empid;
	private String empname;
	public Integer getEmpid() {
		return empid;
	}
	public void setEmpid(Integer empid) {
		this.empid = empid;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public Employee(Integer empid, String empname) {
		super();
		this.empid = empid;
		this.empname = empname;
	}
	@Override
	public String toString() {
		return empid + " " + empname;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((empid == null) ? 0 : empid.hashCode());
		result = prime * result + ((empname == null) ? 0 : empname.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (empid == null) {
			if (other.empid != null)
				return false;
		} else if (!empid.equals(other.empid))
			return false;
		if (empname == null) {
			if (other.empname != null)
				return false;
		} else if (!empname.equals(other.empname))
			return false;
		return true;
	}
	@Override
	public int compareTo(Employee o) {
			
		//return (this.getEmpid()>o.getEmpid())?1:(this.getEmpid()<o.getEmpid())?-1:0;
			
	  // return -this.getEmpid().compareTo(o.getEmpid());
	
		return o.getEmpname().compareTo(this.getEmpname());
	}
	
	
}

Test4.java:
``````````````
package com.oracle.cfw;

import java.util.TreeSet;

public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for TreeSet
		
		TreeSet<Employee> ts = new TreeSet<>();
		
		ts.add(new Employee(100,"rama"));
		ts.add(new Employee(45,"sreeyansh"));
		ts.add(new Employee(78,"riya"));
		ts.add(new Employee(6,"amulya"));
		
		System.out.println(ts);
	}

}


TreeSet implements SortedSet extends Set extends Collection 
{
}

package com.oracle.cfw;

import java.util.TreeSet;

public class Test5 {

	
	public static void main(String[] args) {
		
		TreeSet<Integer> ts = new TreeSet<>();
		
		ts.add(12);
		ts.add(7);
		ts.add(18);
		ts.add(13);
		ts.add(23);
		
		ts.add(9);
		ts.add(8);
		
		System.out.println(ts.first());
		System.out.println(ts.last());
		System.out.println(ts.headSet(13));
		System.out.println(ts.tailSet(13));
		System.out.println(ts.subSet(9, 18));
				
	}
}



Test6.java:
````````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.Collections;

public class Test6 {

	
	public static void main(String[] args) {
		
		ArrayList al = new ArrayList();
		
		al.add(78);
		al.add(8);
		al.add(67);
		al.add(12);
		al.add(18);
		al.add(7);
		
		
		
		//System.out.println(al);
		
		 // Collections.sort(al);
		
		//System.out.println(al);
		
		Collections.sort(al, new MyComparator());
		System.out.println(al);
	}
}

MyComparator.java:
``````````````````
package com.oracle.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Integer> {

	@Override
	public int compare(Integer o1, Integer o2) {
		
		return o2.compareTo(o1);
	}

}


Test6.java:
````````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.Collections;

public class Test6 {

	
	public static void main(String[] args) {
		
		ArrayList<Employee> al = new ArrayList<>();
		
		al.add(new Employee(10,"sreeyansh"));
		al.add(new Employee(8,"amulya"));
		al.add(new Employee(67,"rk"));
		al.add(new Employee(18,"leshviha"));
		
		
		Collections.sort(al, new MyComparator());
	    System.out.println(al);
	}
}

MyComparator.java:
```````````````````
package com.oracle.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Employee> {

	@Override
	public int compare(Employee o1, Employee o2) {
		
		//return o2.getEmpid().compareTo(o1.getEmpid());
	
	    return o2.getEmpname().compareTo(o1.getEmpname());
	}

}

Employee.java:
`````````````````
package com.oracle.cfw;

public class Employee{

	
	private Integer empid;
	private String empname;
	
	
	public Integer getEmpid() {
		return empid;
	}
	public void setEmpid(Integer empid) {
		this.empid = empid;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public Employee(Integer empid, String empname) {
		super();
		this.empid = empid;
		this.empname = empname;
	}
	@Override
	public String toString() {
		return empid + " " + empname;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((empid == null) ? 0 : empid.hashCode());
		result = prime * result + ((empname == null) ? 0 : empname.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (empid == null) {
			if (other.empid != null)
				return false;
		} else if (!empid.equals(other.empid))
			return false;
		if (empname == null) {
			if (other.empname != null)
				return false;
		} else if (!empname.equals(other.empname))
			return false;
		return true;
	}
	
}


Map interface
  
    Integer
	Employee
	... 
	
(key,value) pair then we should go for Map interface.

Map 

  -HashMap
  -LinkedHashMap
  
  
  insertion order is not preserved
  homogenious and heterogenious objects are allowed 
  key objects can not be duplicated whereas value objects can be duplicated
  null insertion is possible for both key and value object(s).
  
 
example:
`````````
package com.oracle.cfw;

import java.util.HashMap;
import java.util.Map;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		//create the object for Map interface
		
		Map m = new HashMap();
		
		m.put(100,"sriyansh");
		m.put(200, "riya");
		m.put(300, "amulya");
		m.put(400, "vedanth");
		m.put("pratik",500);
		
		m.put(100, "rk");
		m.put(600, "riya");
		
		m.put(null, null);
		
		System.out.println(m);
		
		
		
	}

}

 example:
 `````````
 package com.oracle.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		//create the object for Map interface
		
		Map<Integer,String> m = new HashMap<>();
		
		m.put(100,"sriyansh");
		m.put(200, "riya");
		m.put(300, "amulya");
		m.put(400, "vedanth");
				
		for(Map.Entry me:m.entrySet())
		{
			System.out.println(me.getKey() + " " + me.getValue());
		}
		
//		Set s = m.entrySet();
//		
//		 Iterator itr = s.iterator();
//		
//		 while(itr.hasNext())
//		 {
//			 //conveting Map.Entry so that we can get the key&value
//			 
//			 Map.Entry entry = (Map.Entry)itr.next();
//			 System.out.println(entry.getKey() + " " + entry.getValue());
//		 }
		
	}

}


example:
`````````
package com.oracle.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		//create the object for Map interface
		
		Map<Integer,Employee> m = new HashMap<>();
		
		m.put(100, new Employee(10,"sriyansh"));
		m.put(200, new Employee(11,"amulya"));
		m.put(123, new Employee(45,"riya"));
		
		
		for(Map.Entry<Integer,Employee> me : m.entrySet() )
		{
			if(me.getKey()!=123)
			{
				if(me.getValue().getEmpid()==10)
				{
					System.out.println("employee name is: " + me.getValue().getEmpname());
				}
			}
		}
		
	}

}

assignment: 
observe the difference between HashMap & LinkedHashMap


SortedMap
   -TreeMap
   
   
1.it allows only homogenious & comparable  type of objects 
2.duplicate key objects are not allowed where as duplicate value objects 
allowed

3.it will be sorted based on the key object (natural sorting order)

4.null insertion is not possible for key objects 


package com.oracle.cfw;

import java.util.Collections;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test8 {
	
	public static void main(String[] args) {
		
		SortedMap<Integer,String> sm = new TreeMap(Collections.reverseOrder());
		
		sm.put(100, "sriyansh");
		sm.put(200, "riya");
		sm.put(45, "pratik");
		sm.put(2, "amulya");
		
		
		sm.put(78, null);
		
		
		for(Map.Entry<Integer,String> me : sm.entrySet())
		{
			System.out.println(me.getKey() + "==>" + me.getValue());
		}
		
		
		
	}

}

jdbc:
``````
jdbc stands for java database connectivity.

in gneral, if we would like to store the data, we will use db right now 
in the market.

how the data gets stored in the db?
 
    in the form of db objects
	
	tables,view,sequences,indexes, .. 
	
ddl commands,dml commands, dcl,tcl,drl..

create 
insert 
update

delete
select 

 oracle  db

first we need connection from the db, by providing valid credentials.



jdbc -java database connectivity

jdbc is a technology or specification given by sunmicrosystem

and implementations are provided by differnt database vendors

Jdbc interface 

  Oracle,MySql,Ingress,Sybase,postgresql, etc.. 
  
  in the form of jar files. 
  

these jar file names are different from one db to another db.


steps to follow to write the jdbc program:
``````````````````````````````````````````
oracle db

to form the bridge in between java to db, we need one software or one class
i.e driver 


  for every db, they provide 4 types of drivers 
  
  type4 driver -> java , platform indpendent driver
  
  oracle 
  derby 
     type1,type2,type3 & type 4 


1.load the driver class 

       oracle.jdbc.driver.OracleDriver
	   
2.obtain the connection 
	   

jdbc:oracle:thin:@localhost:1521:xe


3.Create the object for Statement  to send the queries

4.process the queries

5.close the connection 


 
  
package com.oracle.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) {
		
		try {
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		System.out.println("got the connection ");
		
		//to send the sql queries from java env to db env
		Statement st = con.createStatement();
		
		String query = "insert into student values(103,'sriyansh')";
		
		//process this query
		
		int x = st.executeUpdate(query);
		
		System.out.println(x + "row(s) inserted");
		
		//close the connetion 
		con.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}


example on PreparedStatement:
`````````````````````````````
package com.oracle.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		
		try {
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		System.out.println("got the connection ");
		
		//to send the sql queries from java env to db env
		PreparedStatement ps = con.prepareStatement("insert into student values(?,?)");
		
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter student id");
		
		int stid = s.nextInt();
		
		ps.setInt(1, stid);
		
		System.out.println("enter student name");
		
		String stname = s.next();
		
		ps.setString(2, stname);
		//process this query
		
		int x = ps.executeUpdate();
		
		System.out.println(x + "row(s) inserted");
		
		//close the connetion 
		con.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}

Statement: it is for processing static queries.
PreparedStatement: it is for processing dynamic queries. 


select * from student;

how to process select queries :
``````````````````````````````````
package com.oracle.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) {
		
		try {
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		System.out.println("got the connection ");
		
		
		
		Statement st = con.createStatement();
		
		
		ResultSet rs = st.executeQuery("select * From student");
		
		while(rs.next())
		{
		System.out.println(rs.getInt(1) + " " + rs.getString(2));
		}
		
		//close the connetion 
		con.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}



how to process meta information:
`````````````````````````````````
package com.oracle.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) {
		
		try {
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		System.out.println("got the connection ");
		
		
		
		Statement st = con.createStatement();
		
		
		ResultSet rs = st.executeQuery("select * From student");
		
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		System.out.println("the no.of columns: " + rsmd.getColumnCount());
		
		
		for(int i=1;i<=rsmd.getColumnCount();i++)
		{
			System.out.println(rsmd.getColumnName(i) + " " + rsmd.getColumnTypeName(i) + "(" +rsmd.getPrecision(i) + ")");
		}
		
		//close the connetion 
		con.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}

batch processing:
```````````````````
package com.oracle.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) {
		
		try {
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		System.out.println("got the connection ");
		
		
		Statement st = con.createStatement();
		
		st.addBatch("insert into student values(105,'pratik')");
		
		st.addBatch("update student set stname='krishna' where stid=100");
		
		
		int x[] = st.executeBatch();
		
		System.out.println(x[0] + " row(s) inserted");
		System.out.println(x[1] + " row(s) updated");
		
		//close the connetion 
		con.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}


lambda expression:
````````````````````

it is an anonymous function

to write the concise code. 


to enable functional programming in java.

doesn't have any name , 
doesn't have any returntype
no need to specify parameter type also, based on the context compiler can decide the parameter
type(s).
doesn't have any access modifier.



public void m1()
{
System.out.println("welcome to lambda expressions");
}

() ->  System.out.println("welcome to lambda expressions"); 


public String getFullName(String fname, String lname)
{
return fname+lname;
}

(String fname,String lname)-> { return fname+lname }

(fname,lname)-> fname+lname;


public int getSquare(int x)
{
return x*x;
}

x->x*x;


interface i1




we can replace with lambda expression when my interface is functional 
interface.

functional interface:
``````````````````````
it is also an interface, but which contains only single abstract method 
we can maintain some otehr default or static methods .


i1.java:
`````````
package com.oracle.java8;

@FunctionalInterface
public interface i1 {

	 //void sum(int x, int y);
	 
	 //String getFullName(String fname,String lname);
	
	   int square(int x);
	   
	   
	 
}

Test2.java:
````````````````
package com.oracle.java8;

public class Test2 {
	// void sum(int x, int y);
	//String getFullName(String fname,String lname);
	public static void main(String[] args) {
		//runtime polymorphism
		//i1 obj = (x,y)->System.out.println("sum is: " +(x+y));
		
		//obj.sum(3, 4);
		
		//i1 obj = (fname,lname)->fname+lname;
		
		//String fullName=obj.getFullName("Rama","oracle");
		
		//System.out.println("fullname is  " + fullName);
		
		//i1 obj = x->x*x;
		//int squareResult = obj.square(2);
		//System.out.println("square of the given number is: " + squareResult);
	}

}

pre-defined functional interfaces:
`````````````````````````````````

Comparator
Runnable 
Callable
... 
Predicate
Function 
Consumer
Supplier 
etc.. 



example with lambda expression:
`````````````````````````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.Collections;

public class Test3 {
	
	//public int compare(Integer o1, Integer o2)
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		for(int i=1;i<=10;i++) {
			al.add(i);
		}
		al.add(0);
		
		Collections.sort(al,(o1,o2)->o2.compareTo(o1));
		
		System.out.println(al);
	
	}

}

with lambda expression alogn with userdefined object(s):
```````````````````````````````````````````````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.Collections;

public class Test3 {
	
	//public int compare(Integer o1, Integer o2)
	public static void main(String[] args) {
		
		ArrayList<Employee> al = new ArrayList<Employee>();
		
		al.add(new Employee(100, "rk"));
		al.add(new Employee(7,"sriyansh"));
		al.add(new Employee(45,"anusha"));
		
	//	Collections.sort(al,(e1,e2)->e1.getEmpid().compareTo(e2.getEmpid()));
		
		Collections.sort(al,(e1,e2)->e2.getEmpname().compareTo(e1.getEmpname()));
		System.out.println(al);
		
		
	
	}

}

Employee.java:
``````````````````
package com.oracle.java8;

public class Employee {
	
	private Integer empid;
	private String empname;
	public Integer getEmpid() {
		return empid;
	}
	public void setEmpid(Integer empid) {
		this.empid = empid;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public Employee(Integer empid, String empname) {
		super();
		this.empid = empid;
		this.empname = empname;
	}
	@Override
	public String toString() {
		return empid + " " + empname;
	}
	
	

}

Predicate
Function 
Supplier 
Consumer . 

boolean	test(T t)

Evaluates this predicate on the given argument.


write a predicate to check whether given number is even or not?

Predicate p = x->x%2==0;

p.test(78);//true
p.test(89);//false


Employee.java:
````````````````
package com.oracle.java8;

public class Employee {
	
	String name;
	String designation ;
	double salary;
	String city;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDesignation() {
		return designation;
	}
	public void setDesignation(String designation) {
		this.designation = designation;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((city == null) ? 0 : city.hashCode());
		result = prime * result + ((designation == null) ? 0 : designation.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		long temp;
		temp = Double.doubleToLongBits(salary);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (city == null) {
			if (other.city != null)
				return false;
		} else if (!city.equals(other.city))
			return false;
		if (designation == null) {
			if (other.designation != null)
				return false;
		} else if (!designation.equals(other.designation))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (Double.doubleToLongBits(salary) != Double.doubleToLongBits(other.salary))
			return false;
		return true;
	}
	public Employee(String name, String designation, double salary, String city) {
		super();
		this.name = name;
		this.designation = designation;
		this.salary = salary;
		this.city = city;
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", designation=" + designation + ", salary=" + salary + ", city=" + city
				+ "]";
	}
	
	
	

}

Test4.java:
````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.function.Predicate;

public class Test4 {

	
	public static void main(String[] args) {
		ArrayList<Employee> list = new ArrayList<Employee>();
		populate(list);
		
	Predicate<Employee> p1 = emp->emp.getDesignation().equals("Manager");
	System.out.println("Manager's information");
	display(p1,list);
	
	
	Predicate<Employee> p2 = emp->emp.getCity().equals("Bangalore");
	System.out.println("Bangalore Employees information ");
	display(p2,list);
	
	System.out.println("All Managers from Bangalore");
	
	display(p1.and(p2),list);
	
	
	}
	
	
	public static void populate(ArrayList<Employee> list)
	{
		list.add(new Employee("rk", "CEO", 30000,"Hyderabad"));
		list.add(new Employee("sriyansh", "Manager", 20000,"Hyderabad"));
		list.add(new Employee("amulya", "Manager", 20000,"Bangalore"));
		list.add(new Employee("Pratik", "Lead", 15000,"Hyderabad"));
		list.add(new Employee("Anusha", "Lead", 15000,"Bangalore"));
		list.add(new Employee("Riya", "Developer", 10000,"Hyderabad"));
		list.add(new Employee("Vedanth", "Developer", 10000,"Hyderabad"));
		list.add(new Employee("Charviha", "Developer", 10000,"Bangalore"));
		
	}
	
	
	public static void display(Predicate<Employee> p,ArrayList<Employee> list) {
		
		for(Employee e: list)
		{
			if(p.test(e))
			{
				System.out.println(e);
			}
		}
		System.out.println("*****************************");
	}
}

Function functional interface:
````````````````````````````````
package com.oracle.java8;

import java.util.function.Function;
//R	apply(T t)
public class Test6 {
	
	public static void main(String[] args) {
		
		Function<String, Integer> f = s->s.length();
	
	   System.out.println(f.apply("rk"));
	   System.out.println(f.apply("oracle"));
	}

}

Function example on user defined object:
``````````````````````````````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.function.Function;
//R	apply(T t)
public class Test6 {
	
	public static void main(String[] args) {
		
		//Function<String, Integer> f = s->s.length();
	
	  // System.out.println(f.apply("rk"));
	  // System.out.println(f.apply("oracle"));
		
		ArrayList<Student> l = new ArrayList<>();
		l.add(new Student("sunny",100));
		l.add(new Student("bunny",65));
		l.add(new Student("Chinny",55));
		l.add(new Student("Vinny",45));
		l.add(new Student("Pinny",25));
		
		
		Function<Student, String> f = s -> {
			
			int marks = s.marks;
			if(marks>=80) {
				return "A[Dictinction]";
			}
			else if(marks>=60) {
				return "B[First Class]";
			}
			else if(marks>=50) {
				return "C[Second Class]";
			}
			else if(marks>=35) {
				return "D[Third Class]";
			}
			else
			{
				return "E[Failed]";
			}
			
		
		};
		
		for(Student s: l)
		{
			System.out.println("student name: " + s.name);
			System.out.println("student marks: " + s.marks);
			System.out.println("student Grade: " + f.apply(s));
		}
		
	}

}



Comparator (java.util)

java.util.function 

Predicate

Function 

Consumer


Supplier 


Consumer example:
```````````````````
package com.oracle.java8;

public class Movie {
	
	String name;
	String hero;
	String heroine;
	public Movie(String name, String hero, String heroine) {
		super();
		this.name = name;
		this.hero = hero;
		this.heroine = heroine;
	}

}

Test7.java:
`````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.function.Consumer;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		//Consumer<Integer> c = s->System.out.println(s+100);

	    //c.accept(123);
		ArrayList<Movie> list = new ArrayList<>();
		
		list.add(new Movie("Bahubali", "Prabhas","anushka"));
		list.add(new Movie("Pushpa","Arjun","Rashmika"));
		list.add(new Movie("Dangal","Ameer","Ritu"));
		list.add(new Movie("Sultan","Salman","Anushka"));
		
		Consumer<Movie> c = m -> {
			
			System.out.println("Movie Name: " + m.name);
			System.out.println("Movie Hero: " + m.hero);
			System.out.println("Movie Heroine: " + m.heroine);
		};
		
		for(Movie m: list)
		{
			c.accept(m);
		}
		
	}

}

Supplier example:
````````````````````
package com.oracle.java8;

import java.util.Date;
import java.util.function.Supplier;

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//Supplier<Date> s = ()->new Date();
		Supplier<Movie> s = ()->new Movie("Pushpa","AlluArjun","Rashmika");
		System.out.println(s.get());
	}

}


iostreams in java:
```````````````````

stream : flow of data in between primary memory to secondary memory 
and viceversa

-write operation (pm to sm) ram hd,fd,
-read operation (sm to pm)

byte by byte - bytestream 
character by character -> character stream

FileReader
BufferedReader


FileWriter
BufferedWriter
PrintWriter


how to create the file in java example:
`````````````````````````````````````````
package com.oracle.iostreams;

import java.io.File;
import java.io.FileWriter;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		File f = new File("abc.txt");
		
		f.createNewFile();
		System.out.println(f.exists());
		
		
		
		
		}
		
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}

how to write the data into the file using FileWriter:
`````````````````````````````````````````````````
package com.oracle.iostreams;

import java.io.File;
import java.io.FileWriter;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		File f = new File("abc.txt");
		
		f.createNewFile();
		System.out.println(f.exists());
		
		
		
		
		}
		
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}

}

drawbacks:

  line separator may or may not work , it will not work in all o.s since 
  it got implemented in c langaugae
  
  we can't store any type of data .
  

example on BufferedWriter:

package com.oracle.iostreams;

import java.io.BufferedWriter;
import java.io.FileWriter;

public class Test3 {
	
	
	public static void main(String[] args) throws Exception{
		
		BufferedWriter b = new BufferedWriter(new FileWriter("abc.txt"));
	
	     b.write("rama");
	     
	     b.newLine();
	     
	     b.write("oracle");
	     b.newLine();
	     
	     b.write(123);
	     
	     System.out.println("write operation has done");
	     
	     b.close();
	     
	}

}

drawbacks:
we can't store any type of data using BufferedWriter , to do this we should

go for PrintWriter class available in java.io package.


FileReader
BufferedReader

  ->character stream related classes.
  
  
FileReader example:
``````````````````
package com.oracle.iostreams;

import java.io.FileReader;

public class Test5 {
	
	public static void main(String[] args) throws Exception  {
		
		FileReader fr = new FileReader("abc.txt");
		
		int x = fr.read();
		
		while(x!=-1) {
		System.out.print((char)x);
		x=fr.read();
		}
	}

}

example on BufferedReader:
```````````````````````````
package com.oracle.iostreams;

import java.io.BufferedReader;
import java.io.FileReader;

public class Test5 {
	
	public static void main(String[] args) throws Exception  {
		
//		FileReader fr = new FileReader("abc.txt");
//		
//		int x = fr.read();
//		
//		while(x!=-1) {
//		System.out.print((char)x);
//		x=fr.read();
//		}
		
		
		BufferedReader br = new BufferedReader(new FileReader("abc.txt"));
	
	     String line = br.readLine();
	     
	    while(line !=null)
	    {
	    	System.out.println(line);
	    	line = br.readLine();
	    }
	}

}

recommended classes to read and write on files is BufferedReader and 
PrintWriter.



Serialization and Deserialization in java:
`````````````````````````````````````````
if you want to transfer the java object over the network , it is not possible
because network won't support object type data 


   object type data -> network supported format (text file) -> serialization 
      writing the object data into network supported format 
	  
	reading the object data from network supported format -> Deserialization


  ObjectInputStream -Deserialization(read operation)-readObject()
  ObjectOutputStream - Serialization(write operation) -writeObject()


Student.java
```````````````
package com.oracle.iostreams;

import java.io.Serializable;

public class Student implements Serializable {
	
	transient Integer stid; 
	String stname;
	public Student(Integer stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public String toString() {
		
		return stid + "  " + stname;
	}

}

Test6.java:
`````````````
package com.oracle.iostreams;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
//demo on serialization 
public class Test6 {

	public static void main(String[] args) throws Exception {
		
		Student st1 = new Student(100,"Rama");
		//Student st2 = new Student(101,"sriyansh");
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("abc.txt"));
		
		oos.writeObject(st1);
		
		System.out.println("serialziation has done ");
		
		oos.close();
	}
}

Test7.java
````````````
package com.oracle.iostreams;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

//demo on deserialization
public class Test7 {

	
	public static void main(String[] args) throws Exception{
		
		//crate the object for ObjectInputStream 
		
		ObjectInputStream ois = 
		new ObjectInputStream(new FileInputStream("abc.txt"));
		
		
		Student st = (Student)ois.readObject();
		System.out.println(st);
		
	}
}


default methods and static methods inside an interface:
````````````````````````````````````````````````````````
java 1.8 v they introducted default methods & static methods also inside 
an interface 

   defender methods
   
   interface i1{
	   default void m1(){
	   sysout("default method");
	   }
   }

class Test impelements i1{
  main(){
    Test obj = new Test();
	obj.m1();
  }
}

interface Left
{
   default void m1(){
     sysout("left default method");
   }
}

interface Right
{
   default void m1()
   {
   
     Sysout("Right Default method");
   }

}

class Test implements Left,Right{
  public void m1()
   {
   
     Left.super.m1();
   }
   
   main(){
   
    Test t = new Test();
	t.m1();
	
   }

}





Method Reference:
```````````````````

::

Functional interface method can be mapped to our specified method by using 
:: operator. 
this is called method reference.

our own method can be either static or instance method. 

functional interface method and our specific method should have same argument
types except this , the remaining things like returntype, method name, modifiers etc are not 
required to match.

syntax:

  classname::methodname-if the method is static method 
  
  objref::methodname - if the method is instance method.
  
  Functional interface can refer lambda expression 
  and Functional interface can also refer method reference. 
  Hence lambda expression can be replaced with method refence. 
  
  
 With lambda expression example:
``````````````````````````````````
package com.oracle.java8;

public class Test10 {
	
	public static void main(String[] args) {
		
		Runnable r = ()->{
			
			for(int i=0;i<=10;i++)
			{
				System.out.println("CHILD THREAD");
			}
		};
		
		
		Thread t = new Thread(r);
		t.start();
		
		for(int i=0;i<=10;i++) {
			
			System.out.println("MAIN THREAD");
		}
	}

}

 
example:
`````````
package com.oracle.java8;

public class Test10 {
	
	
	public  void m1()
	{
		for(int i=0;i<=10;i++)
		{
			System.out.println("CHILD THREAD");
		}
	}
	
	public static void main(String[] args) {
		
		//Runnable r = Test10::m1;
		
		Test10 obj = new Test10();
		Runnable r = obj::m1;
		
		Thread t = new Thread(r);
		t.start();
		
		for(int i=0;i<=10;i++) {
			
			System.out.println("MAIN THREAD");
		}
	}

}


example:
`````````
package com.oracle.java8;

interface i12 {
	   void m1(int i);
}
public class Test11 {

	public void m2(int i) {
		System.out.println("from method refeence: " +i);
	}
	
	public static void main(String[] args) {
		i12 obj = i->System.out.println("from lambda expression " + i);
		obj.m1(34);
		Test11 obj1 = new Test11();
		
		i12 obj2 = obj1::m2;
		obj2.m1(45);
		
	}
}

constructor reference:
`````````````````````````
  classname::new
  

streams:
`````````
java.util.stream and java.io.stream 

java.util.stream -> is meant for processing objects from the collection.

collection and stream :

stream()

stream() is available as a default method to every collection 
from 1.8 v onwards.

Stream s = c.stream();
where c is any collection 

Stream is an interface -java.util.stream package


1.configuration -filter mechanism or map mechanism
2.processing-collect(),count(),sorted(),min(),max(),forEach(),toArray(),Stream.of()


Stream s = c.stream();
Stream s1 = s.filter(i->i%2==0);

mapping:
````````
if we want to create a separte new object for every object present in the 
collection based on our requirement we should go for map().

public Stream map(Function f)


Stream s = c.stream();
Stream s1 = c.map(i->i+10);

without streams:
```````````````````
package com.oracle.java8;

import java.util.ArrayList;

public class Test12 {

	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		for(int i=1;i<=10;i++) {
			al.add(i);
		}
		
		System.out.println(al);
		ArrayList<Integer> al1 = new ArrayList<Integer>();
		
		for(Integer i:al) {		
			if(i%2==0) {
				al1.add(i);
			}
		}
		System.out.println(al1);
	}
}

with stream api:
``````````````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Test13 {
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		for(int i=1;i<=10;i++) {
			al.add(i);
		}
		
		List<Integer> l1 = al.stream()
		.filter(i->i%2==0)
		.collect(Collectors.toList());
		
		
	    System.out.println(l1);
	}

	}
	
	filter() along with collect()
	
	map() along with collect()
	

min() and max()

forEach()

example:
`````````
package com.oracle.java8;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Test14 {
	
	public static void main(String[] args) {
		
		ArrayList<String> al = new ArrayList<String>();
		al.add("rk");
		al.add("amulya");
		al.add("sriyansh");
		al.add("prathik");
		al.add("madhumitha");
		al.add("oracle");
		
		System.out.println(al);
		
		ArrayList<Integer> al1 = new ArrayList<Integer>();
		for(int i=1;i<=10;i++) {
			al1.add(i);
		}
				
		
		//List<String> l2 = al.stream().map(f->f.toUpperCase()).collect(Collectors.toList());
	    
		//long count =al.stream().filter(s->s.length()==5).count();
		//System.out.println("the number of 5 length strings are:" +count);
	    //sorted()
		
		//List<String> l2 = al.stream().sorted().collect(Collectors.toList());
	    //System.out.println("according to default natural sorting order: " + l2);
		
		List<String> l2 = al.stream().sorted((i1,i2)->i2.compareTo(i1)).collect(Collectors.toList());
	
		System.out.println("according to customized sorting order: " + l2);
		
		
		Integer min = al1.stream().min((s1,s2)->s1.compareTo(s2)).get();
		System.out.println("Minimum value is  : " + min);
		
		Integer max = al1.stream().max((s1,s2)->s1.compareTo(s2)).get();
		System.out.println("Maximum value is  : " + max);
	
		
		al.stream().forEach(s->System.out.println(s));
		
		System.out.println("=========================");
		al.stream().forEach(System.out::println);
	
	    Stream s = Stream.of(99,88,77,96,55,34);
	    s.forEach(System.out::println);
	}

}

filter()
map(),
count(),
forEach(),
min(),
max(),
sorted(),
sorted(Comparator)
collect()
of()



jpms:
`````
  java platform module system.
  
  modularity concept introduced in java9 as the part of jigsaw
  project.
  2005
  jep
  java 7 (2011)
  java 8(2014)
  
  jar file is nothing but group of packaages and 
  each pacakage contains several .class files.
  
  module.
  
  by using module concept.
  module is a group of packages similar to jar file.
  module can contain configuration information also.
  
  
  module-info.java
  
  3 module
  each and every module should contain module-info.java
  
 in java9, jdk itself modularized.

  all classes of java 9 are grouped into multiple modules(around 98)
like 
    java.base
    java.logging
    java.sql
....
System.out.println(String.class.getModule());//module java.base


what is the need of jpms:
``````````````````````````
problem 1:
````````````
unexpected NoClassDefFoundError in middle of program execution 







problem 2:
````````````
version conflicts or shadowing problems.

classpath = jar1;jar2;jar3;jar4;


if jar4 requires Test.class file of jar3.

jar1 - Test.class 
jar2 - Test.class
jar3 - Test.class


problem3:
security problem.


public is too much public in jar files.
public is not really that much public in java9 module system.

we can export particular package of module.

module can offer strong encapuslation than jar file.


problem4:
```````````
jdk/jre having monolithic arechitecture and very large size.

jdk 1.0 -> 250+ classes
jdk 1.1   500+ classes
jdk 1.8 v - > 4000 + classes

60mb

module-info.java:
``````````````````
module moduleName{

1.what other modules required by this module
2.what packages exported by this module for other modules.
}

module moduleA
{
   
}


	
  javac --module-source-path src -d out -m moduleA
  
  java --module-path out -m moduleA/pack1.Test1
  
  
  
  inter module dependencies :
  
  
  within the application we can create any number of modules 
  and one module can use other modules.
  
  
	 we can define module dependencies inside module-info.java
	 
	 
	 module moduleName{
	 
	   //what other modules reequired by this current module
	   //what packages exported by this module for other modules
	 }

mainly we can use 2 types of directives

  1.requires 
  
  2.exports 


requires directive:
 
   it can be used to specify the modules which are required 
   by current module.
   
     module moduleA{
	 
	    requires moduleB;
		requires moduleC;		
	 }

requires moduleA,moduleB -> invalid

2.exports:
```````````
it can be used to specify what packages exported by current module to the 
other modules.

  module moduleA{
  
      exports pack1;
	  exports pack2;
  }

exports pack1,pack2;-->invalid

module modulename
{
   requires modulename;
   exports packagename;
}



module A contains 3 packages 
pack1,pack2 and pack3

module moduleA{

   exports pack1;
   exports pack2;
}

by importing the main package, we can access all main package related classes
by importing sub package, only sub package information we can access 
by importing sub package, don't expect main package information .



xml:
```
xml -extensible mark up language

  pre-defined tags
  user-defined tags
 
 
html -> hyper text markup language 

 it contains all are predefined 
 w3c 
 if our requirement is to present the data -> html 
 if our requirement is to describe the data -> xml 
 
w3c rules 

<root attribute="">
  <child></child>

</root>


<Person>
   <name>rk
   hyd</address>
   <company</company>
<Person>


where we are using xml:

data transformation 
configuration files
  web.xml,pom.xml , ....

DriverLicense.xml:
`````````````````````
<?xml version="1.0" encoding="UTF-8"?>

<DriverLicense status="suspended">
  <Number>123</Number>
  <FirstName>Rama</FirstName>
  <LastName>Krishna</LastName>
  <DateOfBirth>12/Nov/1988</DateOfBirth>
  <VehicleType>Car</VehicleType>
  <DateOfIssue>11/June/2023</DateOfIssue>
  <ExpiryDate>11/June/2028</ExpiryDate>
  <Photo location ="servername/filename"/>
  <Address>
     <street>stevens dr</street>
     <city>king of prussia</city>
     <state>PA</state>
     <country>USA</country>
     <zipcode>19406</zipcode>
  
  </Address>

</DriverLicense>

patient.xml:
``````````
<?xml version="1.0" encoding="UTF-8"?>
<tns:Patient xmlns:tns="http://www.rk.org/Patient" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.rk.org/Patient Patient.xsd ">
  <tns:name>Rama</tns:name>
  <tns:age>22</tns:age>
  <tns:email>rk@gmail.com</tns:email>
  <tns:gender>M</tns:gender>
  <tns:phone>12345</tns:phone>
  <tns:paymentType>
    <!-- <tns:cash>3450</tns:cash> -->
    
    <tns:insurance>
    
       <tns:provider>icicilombard</tns:provider>
       <tns:limit>500000</tns:limit>
    
    </tns:insurance>
  </tns:paymentType>
</tns:Patient>

patient.xsd:
``````````````
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
	targetNamespace="http://www.rk.org/Patient"
	xmlns:tns="http://www.rk.org/Patient" elementFormDefault="qualified">


	<element name="Patient" type="tns:Patient"></element>

	<complexType name="Patient">

		<sequence>

			<element name="name" type="tns:String15Chars" />
			<element name="age" type="int" />
			<element name="email" type="string" />
			<element name="gender" type="tns:Gender" />
			<element name="phone" type="string" />
        	<element name="paymentType" type="tns:PaymentType" />

		</sequence>


	</complexType>

	<complexType name="PaymentType">

		<choice>


			<element name="cash" type="decimal"></element>
			<element name="insurance" type="tns:Insurance"></element>

		</choice>

	</complexType>


	<complexType name="Insurance">

		<all>

			<element name="provider" type="string" />
			<element name="limit" type="decimal" />

		</all>


	</complexType>

	<simpleType name="String15Chars">
		<restriction base="string">
			<maxLength value="15"></maxLength>
		</restriction>

	</simpleType>

	<simpleType name="Gender">

		<restriction base="string">
			<enumeration value="M" />
			<enumeration value="F" />

		</restriction>

	</simpleType>

</schema>



