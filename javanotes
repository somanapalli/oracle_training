java :

 what is java?
 
    java is oo pl.
	
  platform independent -> wora -> write once run / reuse anywhere.

  

why pl?
 
   ->to develop the software/applications
   
 c,cpp,java,python,.net ..-> s/w
 
 what kind of applications we have?
 
  1.standalone applications/desktop applications
  
  ->calculator,antivirus,acrobatic reader etc...
  
    results are not sharable across the globe.
	
    console based applications.
	
  2.internet based applications
   
      ->google,gmail,facebook... 

    results are sharable across the globe.
	
	
java:
`````
    1995
	
	28 years 
	
      
java is maintaining popularity.

->because of it's charactersitcs/features/buzzwrds

1.platform independent
2.secured
3.robusted
4.simple
...

windows:

c program (.c)

compile: .exe

run: output


windows:
  are you able to execute this program? 
  yes
  
  
  
  c is platform dependent
  
 windows 
  .java
  .class
  
 unix
    yes
	java is platform independent.
	
  one os to other os.

  java program ->programmer responsibility 
  
  steps you have to follow to write the java program?
  
   syntax: rules are given by language vendors
   
   in case of java, sunmicrosystem org, oracle
   
   java is open source 
   
   1.download the java software -> jdk
   2.install the software
   3.select the editor
   4.write the java program 
   5.save the java program (.java)
   6.compile the java program (.class)
   7.run/execute the java program 
  
  
 structure of the java program?
 printf - c language
 java is case sensitive programming languagge
 
 
  java program should starts with by defining the class.
  
    class Test1
	{
	    public static void main(String[] args){
		
		  //logic
		  
		  System.out.println("welcome to java from oracle");
		}
	}
  
  java program execution starts from main() method
 
in c program -> main()
in java program -> public static void main(String[] args){} 
  
  
  command to compile the java program?
  
     javac <filename>.java
	 
	 javac Demo.java
	 
  .java file contains - source code (developer)  -> java compiler 
  
  java compiler will take source code as an input and gives 
  .class file .
  
  
  .class file contains -> byte code 
  
  byte code is not human readable code which can be understandable 
  by jvm(java virtual machine)
  
  who is compiling the java program ? -> java compiler 
  
   java compiler -> predefined java program available in jdk
   
  who is executing the java program?
  
    jvm -> java virtual machine -> 
	jvm will take .class file as an input (byte code) and converts
	machine level code. 
	
command to execute the java program?

     java <classname>
	 
	 java Test1
	 
 how java  is oopl?
 
 if any pl is said to be object oriented, it has to follow some 
 principles.
 
   1.oops principles.
   
   ->omg(object management group)
   
  how many oops principles we have?

    1.inheritance
    2.encapsulation 
    3.abstraction 
    4.polymorphism

how can we achieve in java?

 	by using two concepts
	
	1.class 
	2.object


java program should starts with by defining the class only.

class <classname>
{
     //variables
	 //methods	 
}	
	
 class is a collection of variables and methods into a single unit. 
 that single unit is known as class. 
 
  
  variables:
  
     to store the data we have to provide the names. 
	 
	 syntax:
	   
	    
		  <datatype> <variablename> =<value>;
		  
		  int x = 100;
		  
how many datatypes are available in java?
 8 datatypes
 
 byte,short,int,long  - Integer category
 
 float,double  - float category 
 
 char  ->character category -> to store single character information 
 
 boolean  -> boolean category -> to store logic values (eitehr true or false)
 
 all these are valid
 
 byte b = 100;//1 byte 
 
  -128 to 127
  
  1 byte 
  
 short s = 100;
 
   2 bytes
   
   
 int i = 100;
 4 bytes
 
 long l = 100;
 
 8 bytes
 
 
 every datatype is maintaining two things
 
   1.range
   2.memory size
   
   
 -2^n-1 to 2^n-1 - 1
 n ->no.of bits 
 
 1 byte -> 8 bits
 -2^7 to 2^7 -1
 
 -128 to 127
 
  float f = 4.5f;//valid ->4 bytes
  
  double d = 8.9;//valid   -> 8bytes 
  
  
  
  by default decimal type value is of double type in java
  
 
   char c = 'a';
   
   boolean b = true;
   
   
  all java reserved words must be in lower case
  
  boolean b = false;
  
 methods:
 ````````
 functions -> in c language
 ->to write the logic 
 
 method is also a place, where we are writing the logic, to perform 
 some operations based on the requirement.
 
 
  syntax:
   
       
    method heading-> 
	
	[accessmodier] <returntype> <methodname>([parameters]){
	 
	   //logic -method body
	 }


class is a collection of variables and methods into a single unit.

example:

define one method which displays helloworld message?

  void is representing returntype 
  meaning is not returning any value. 
  
    void displayInfo(){
	   System.out.println("helloworld");
	}

define one method which returns your name?

    String getName(){
	   return "rk";
	}

return value & return type always must be 
compatible with each other.
char ch='a';
String s = "rama";


define one method which takes firstname,lastname as two parameters and 
returns fullname is the combination of firstname and lastname?

   
   String getFullName(String firstName,String lastName){
     return firstName+lastName;
	 
   }
   
   
   getFullName("rk","oracle");
   
     ->rkoracle


define one method which takes two integer values and displays their 
sum?

 void getSum(int x, int y)
 {
   System.out.println("sum is: " +(x+y));
 }
   
   string + anythig is string only 
   
   
  getSum(7,6)
  
    ->sum is: 13
	
	
before i am doing the program on class 
i would like to introduce one ides

 eclipse
 netbeans 
 
   intellij
   myeclipse..


 the code which we are writing in the ide is autocompiled
 we no need to compile the code manually.
 
 we should keep always our userdefined classes or interfaces 
 inside package only .
 it is highly recommended.
 
   inside a single package, how many classes we can define?
     as many as we want
	 
	inner method definition is not possible in java
	
	we can't define the method inside another method.
	but we can call the method from another method(inner method invocation)
	
	whenever we execute the java program, jvm will invoke main method 
	only not our own methods 
	
	who needs to call our own method(s)?
	  programmer.
	  

object:

object is an instance of the class. 
object is real world entity.

human is the class. 

are we occupying any space in the earth?
  
by just defininig the class, memory won't be created 
we are not allowed to store the data.

we have to create the object?
 whenever we create the object, memory will be created for instance properties
 when memory will be created , we are able to store the data which 
 we declared insdie the class.
 
 
 syntax:
 
   <classname> <objectname> = new <classname>();
   
   Student obj = new Student();
   
  
package com.oracle.corejava;
public class Student {
    
    //variables
    
    int stid=100;
    String stname="amulya";
    
    //define one method for displaying above data
    public void displayStudentInfo(){
        
        System.out.println("student id is : " + stid);
        System.out.println("student name is: " + stname);
    
    }
    
    public static void main(String[] args) {
        
        //create the object for Student class
        
       Student obj = new Student();
        
      // System.out.println("student id is : " + obj.stid);
      // System.out.println("student name is: " + obj.stname);
        
        //call the method using object name
        
        obj.displayStudentInfo();
    }
    
}

     private
	 default
	 protected
	 public 
	 
	  using these access modifiers we are able to restrict the 
	  visibiility of the data over the packages.
	  

for a single class, how many objects we can create?
 as many as we want based on the requirement.
 
 1000 students are studying 
 
  assume i want to store 1000 students information?
  
     1000 objects we have to create
	 every object is having one student information .
	 
	 in a single object, can we store multiple student(S) information?

1000
	 
stname
stid
staddresss
collegename


 int x;//non static variable or instance variable
 static String collegeName;//static variable.
 
 for static properties memory will be created only once
 where as for non static properties memory will be created 
as many no.of times based on the object createion .


 when memory will be created for static properties?
 
  whenever class is loaded into main memory (classloader subsystem)-jvm
  only one time. 
 
nonstatic or instance method
 
 void m1(){
    //instance area
 }


 static void m1(){
 // static area


public static void main(String[] args)
{
   //static area
}



instance area:

instance area is an area which belongs to instance or non-static method.


static area: 

static area is an area which belongs to static method 


we can access the static properties in following ways from any area
either static or non-static area 


 1.directly 
 2.using class name 
 3.using object name 
 
 

from static area if we want to access non-static or instance properties 
it is possible by using object name. 


package com.oracle.corejava;
public class Student {
    
    
    //instance variables
    int stid=100;
    String stname="amulya";
    //static variable
    static String collegeName="HCU";
    
    //define one method for displaying above data
    void displayStudentInfo(){
        //instance area
        System.out.println("student id is : " + stid);
        System.out.println("student name is: " + stname);
        System.out.println("college name is: " + collegeName);
        System.out.println("college name using classname:" + Student.collegeName);
        
    }
    
    public static void main(String[] args) {
        //static area
        //create the object for Student class
        
       Student obj = new Student();
        
     System.out.println("student id is : " +obj.stid);
     System.out.println("student name is: " + obj.stname);
     
     //accessing static property from static area 
     
        System.out.println("college name is: " + collegeName);
        System.out.println("college name using classname:" + Student.collegeName);
        System.out.println("college name using object name: " +obj.collegeName);
    }
    
}

    //business logic class
	class Test1{
	
	    int x=100;
		static String y = "Rama";
		
		//instance method
	    public void display()
		{
		      System.out.println(x + " " +y);
  		}
	}
	
	//execution logic class
	class Test2{
	
	  public static void main(String[] args)
	  {
	  //static area
	  
	    Test1 obj = new Test1();
		obj.display();
	  
	  }
	 }
	
	
	
java is object oriented programming language

	1.inheritance
	2.polymorphism
	3.encapsulation 
	4.abstraction 
	
inheritance:
````````````
	inheritance is the process of taking the properties from 
	one class to another class. 
	
	
	class Test1{
	  //logic1 
	}
	
	class Test2{
	  //reuse logic1
	}
	
	if a particular logic is common, instead of redefining the code 
	again and again, what we have to do?
	
	   we have to reuse.
	   
	  duplication of the code will be improved. 

	  memory consumption increased 
	  
	  ->performance will be degraded.
	  
by using inheritance it is possible to reuse the exisiting properties 
from one class to another class. 

	 using one java reserved keyword-> extends keyword-
	 
	
	
	
	whenever we implemented the inheritance concept, parent class 
	properties(variables,methods,..) will be inherited from parent class 
	to child class.
	
	Test1.java:
	````````````
	/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
//parent class
public class Test1 {
    
    
    public void sum(int x, int y){
        System.out.println("sum is : " +(x+y));
    }
}

Test2.java:
```````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */

//try to make this Test2 class as child class
//child class
public class Test2 extends Test1{
    
     public static void main(String[] args) {
        
         Test2 obj = new Test2();
         obj.sum(4,4);
    }
}

note:
using extends keyword, we are able to inherit the properties from 
single class to single class only more than single it is not possible. 
we will get compile time error. 

Test1.java:
````````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
//parent class
public class Test1 {
    
    
    public void sum(int x, int y){
        System.out.println("sum is : " +(x+y));
    }
}

Test2.java:
`````````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */

//try to make this Test2 class as child class
//child class
public class Test2 extends Test1{
    
    public void sub(int x, int y)
    {
       System.out.println("substractio is: " + (x-y)) ;  
    }
     public static void main(String[] args) {
        
         Test2 obj = new Test2();
         obj.sum(4,4);
         obj.sub(7,6);
         
         //Test1 obj = new Test1();
         
         //obj.sum(3,4);
         //obj.sub(6,5);
    }
}


for every java class(predefined or userdefined), there is a super class , root class 

   java.lang.Object 
   
   
class Test1 {

}

class Test2 extends Test1{
}

class Test3 extends Test2{
}
	
	  Object
	System 
	String
	ArrayList 
	   .. 
	Test1,Test2,.. -> Object 
	
	
note:
every java class is an example of inheritance.

example:
`````````
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.oracle.inheritance;

/**
 *
 * @author LENOVO
 */
public class Demo {
    
    public static void main(String[] args) {
        
        //create the object for Demo class
        
        Demo obj = new Demo();
        System.out.println(obj.toString());
        
        System.out.println(obj.hashCode());
        
        System.out.println(obj.getClass());
        
    }
    
}


encapsulation:
```````````````
the process of wrapping up of datamembers(variables) and member 
functions(methods)into a single unit. 
this process is called encapuslation 

	ex: class is the best example for an encapsulation.
	
	
rules to make a normal java class as an encapsulated class 

1.should define private variables
2.should define public setters and public getter method(s).

encapsulated classe(s).


	setter method purpose is -> to set the data into an object
	getter method purpose is -> to get the data from an object
	
	default values are there based on the datatype. 
	
	  for all integer category default value is 0
	  
	  for all float category default value is 0.0 
	  
	  for boolean - > false
	  for character -> 
	  
	  for string -> null 
	  
	
	data hiding , 
	 ->security 
	 
	inheritance,encapsulation 
	
	
polymorphism:
`````````````
it is also one of the oop principle. 

 one form into many forms. 
 
  1.method overloading
  2.method overriding
  
  
in java, we have 

  1.compile time polymorphism-method overloading
  2.runtime polymorphism-method overriding
  

  
 method overloading:
 
  method name is same 
  but parameters are different
  
     type,no.of,orderof parameters
	 
m1(int x, String y){}
m1(String x, int y){} -changing the order
m1(float x, float y){}-type of parameters
m1(int x, String y, double z)-no.of parameters

example:
`````````
package com.oracle.polymorphism;

public class Test1 {
	
	public void operation(int x, int y) {
		System.out.println("integer sum is : " +(x+y));
	}

	public void operation(double x, double y) {
		System.out.println("double sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.operation(2.3,4.5);
		obj.operation(6, 7);
	}	
}

above example we can consider as an example for compile time polymorphism
since polymorphism can be resolved at compile time meaning that method 
calling is binded with specific method using reference variable at 
compile time by the compiler.



method overriding:
```````````````````
method name is same (method prototype)including parameters

method body is different from parent class to child class. 

meaning that if you want to achieve method overriding, for sure 
we should maintain inheritance relation in between classe(s).


note
minimum we require 2 classes with parent child relation then only 
we can achieve method overriding.


why should we go for method overriding?

->to achieve the concept of runtime polymorphism.
->if we are not interested to execute existing(parent class) logic



A.java:
`````````
package com.oracle.polymorphism;

public class A {

	public void operation(int x, int y) {
		System.out.println("sum is: " +(x+y));
	}
}

B.java:
`````````
package com.oracle.polymorphism;
//child class cum execution logic class
public class B extends A{

	@Override
	public void operation(int x, int y)
	{
		System.out.println("substraction is: " +(x-y));
	}
	public static void main(String[] args) {
		
		B obj = new B();
		obj.operation(4,3);
	}
}


method overriding - runtime polymorphism.

A.java:
```````
package com.oracle.polymorphism;

public class A {

	public void operation(int x, int y) {
		System.out.println("sum is: " +(x+y));
	}
}


B.java:
````````package com.oracle.polymorphism;
//child class cum execution logic class
public class B extends A{

	@Override
	public void operation(int x, int y)
	{
		System.out.println("substraction is: " +(x-y));
	}
	public static void main(String[] args) {
		
		//B obj = new B();
		//obj.operation(4,3);
		
		//A obj = new A();
		//obj.operation(3, 4);
		//converting child type object to parent type object -upcasting
		 A obj=new B();//Runtime polymorphism
		 obj.operation(4, 3);
		 
		 //Converting parent type object to child type object - downcasting
		 //B obj = (B)new A();
		 //obj.operation(4, 3);
		
	}
}

abstraction:
`````````````
abstraction refers hiding internal implementation details 
and providing functionalites to the end user. 



 sending one message from my mobile to my friend mobile. 
 we are not focusing on how object can provide the service. 
 we are just focusing on what that object can provide?
 
 
-abstract class
-interface

abstract class:
````````````````

if a class contains any undefined method, then it is mandatory 
to make that class as an abstract class otherwise we will get 
compile time error. 

 abstract class Test1{
    abstract void sum(int x, int y);//declare the method
 }

we are not allowed to create the object for an abstract class. 

if any property is common , make that as an abstract and define 
with differnt logics in different classes based on the requirement.

for a single abstract class, how many implementation classes we can define?

based on the requirement, as many as we want.

from one implementation class to anotehr class implementation class 
logic is going to be different.


 Test1.java:
`````````````
package com.oracle.abstraction;

public abstract class Test1 {
	
	
	public abstract void operation(int x, int y);

}


Test2.java:
```````````
package com.oracle.abstraction;

//implementation class 
public class Test2 extends Test1 {

	@Override
	public void operation(int x, int y) {
		
		System.out.println("sum logic :" +(x+y));

	}

}

Test3.java:
````````````
package com.oracle.abstraction;

//implementation class
public class Test3 extends Test1 {

	@Override
	public void operation(int x, int y) {
		System.out.println("division is: " +(x/y));
	}

}

Test.java:
````````````
package com.oracle.abstraction;

//execution logic class
public class Test {

	public static void main(String[] args) {
		
		//create an object of Test1 class
		//runtime polymorphism - upcasting
		//Test1 obj = new Test2();
		Test1 obj = new Test3();
		obj.operation(4, 2);
		
	}
}

using abstract class, we can achieve the abstraction in between 
0 to 100%
 
  to achieve 100% abstraction we will go for 
  interface(s).
  
interface:
``````````
  syntax:
   
       interface <interfacename>
	   {
	        //constants
			//abstract methods

	   }
	  
	  
	ex:
  
        interface i1{
              void m1();
         }

by default interface methods are public abstract , we no need 
to write explicitly like abstract classe(s).
by default interface variables are public static final.

can we create the object for interface:

 i1 obj = new i1();
 obj.m1();
	
creating the object for an interface is nothing but creating the object
for it's implementation class. 

 
by using implements keyword, we are allowed to bring the interface 
properties to the implementation class.


Bank.java:
```````````
package com.oracle.abstraction;

public interface Bank {
	
	double getRateOfInterest();

}

package com.oracle.abstraction;

public class Icici implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5.5;
	}

}

package com.oracle.abstraction;

public class CityBank implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

package com.oracle.abstraction;

public class Test4 {
	
	public static void main(String[] args) {
		
		//Bank obj = new Icici();
		
		//System.out.println("icici bank rate of interst is: " + obj.getRateOfInterest());
		
        Bank obj = new CityBank();
		
		System.out.println("City bank rate of interst is: " + obj.getRateOfInterest());
	}

}


Access modifiers:
`````````````````

private 
default is not a java keyword
protected
public

 int x; //default variable
 
purpose: these are used to control the visibiility of the data over 
the packages.

private properties we are allowed to access only with in the class

package com.oracle.accessmodifiers;

public class Test1 {
	
	private int x=100;
	
	private void display() {
		System.out.println(x);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		System.out.println(obj.x);
		obj.display();
	}

}
package com.oracle.accessmodifiers;

public class Test2  {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		//obj.x;
		//obj.display();
	}
}

default:
with in the package, from any class we are allowed to access 
default properties

but from other package any class, we are not allowed to acecss the 
default properties.

protected:
with in the package we can access 
otehr package independent class - we cannot access
other package sub class or child class - we can acecss 

public:
there is no restriction from any package any class we are allowed 
to acess the public property 

universal access modifier


exception handling:
```````````````````
exception:

  in general , while we are writing the code, we may get errors 
  
    1. at compile time - because if you are making any mistakes 
	                     syntactically 
						 
	compiletime errors 
	
	runtime erros(exceptions):
	
	2.errors which occurs at runtime meaning that during execution 
	  of the java program.
	  
	  
	why are we getting these exceptions?
	
	  because of logical errors
	  
	  division of two numbers
	  
	  enter firstnuber: 4
	  enter second number: 0
	  
	  division: java.lang.ArithmeticException:/by zero
	  
	  atm machine 
	  
	    enter amount: 4000
		
		4000
		
		insufficient funds, please check your account

		
		

if you pass any invalid data, jvm couldn't process 
in return we will get runtime errors(Exceptions)

drawbacks if we get any exceptions?
1.abnormal termination 
2.we will get system error messages which are not understandable by 
  end user even which is not recommended.
  
exception handling:
```````````````````
as a programmer we should handle that exception.
 
 1.we can escape from abnormal termination meaning that 
   able to achieve normal flow of exceution. 
   
   
 2.instead of getting system error messages we can provide user 
 friendly messages which can be understandable by every end user.
 
 
 how can we handle the exceptions?

  using 5 java reserved keywords


 1.try 
 2.catch 
 3.finally 
 4.throws
 5.throw
 

try block:
`````````````
try block is used to keep the problematic statements which causes 
problems at runtime.

syntax:
  try
  {
    //problematic statements
  }


catch:
``````
catch block is used to catch the exception and provides user friendly 
message.

syntax:

  catch(exceptionclassname <referenevariablename>)
  {
    //user friendly message
  }

example:
`````````
package com.oracle.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		int x =100,y=0;
		try {
		int z = x/y;
		
		System.out.println("division is: " +z);
		}
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */


once control comes from try block to catch block, it will never go back 
to the try block.

for a single try block, how many catch blocks we can define?
 as many as we want based on the requirement.
 
 


in java, who is the parent class for every class in java?

   java.lang.Object
   
   
   for all these exception classes, who is acting as the 
   super class?
   
   

class ArithmeticException extends RuntimeException extends Exception 
extends Throwable extends Object
{
}

FileNotFoundException is the checked exception 

class FileNotFoundException extends Exception extends Throwable 
extends Object{
}

while we are handling the exception , the order always from 
child to parent (specific to general ) not from parent to child 
(general to specific)

example:
`````````
package com.oracle.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		
		Scanner s =new Scanner(System.in);
		
		try {
			
			System.out.println("enter the first number");
			int fno = s.nextInt();
			System.out.println("enter the second number");
			int sno = s.nextInt();
			
			int division = fno/sno;
			
		    System.out.println("division is : " + division );
		}
		
		
		catch(RuntimeException re) {
			System.out.println(re);
		}
//		catch(ArithmeticException ae)
//		{
//			System.out.println("don't enter zero as a denominator");
//		}
//		
//		catch(InputMismatchException im)
//		{
//			System.out.println("please pass only numeric values");
//		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */

try-keep the problematic statments
catch -catch the exception and provides ufm

finally block
 -finally block is used to keep closing related logic 
 -like db connetion closing logic, file closing logic etc.. 
 -once we keep any logic inside the finally block, that logic will be 
  executed everytime whether in positive scenario and negative scenario.
 
example:
`````````
package com.oracle.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		
		Scanner s =new Scanner(System.in);
		
		try {
			
			System.out.println("enter the first number");
			int fno = s.nextInt();
			System.out.println("enter the second number");
			int sno = s.nextInt();
			
			int division = fno/sno;
			
		    System.out.println("division is : " + division );
		}
		
		
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		catch(InputMismatchException im)
		{
			System.out.println("please pass only numeric values");
		}
		
		finally {
			
			System.out.println("finally block executed always");
		}
		
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		System.out.println("rest statements not executed");
		
	}
	
	

}
/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.oracle.exceptions.Test1.main(Test1.java:9)

 * 
 */


throws :
````````
throws is a java reserved keyword which gives an 
indication to the calling 
function to keep the called function under try and 
catch block.

package com.oracle.exceptions;
//called program 
public class Test2 {

	//called method
	public void division() throws ArithmeticException
	{
		int x=100,y=0;
		System.out.println("division is: " +x/y);
	}
}


package com.oracle.exceptions;
//calling program
public class Test3 {
	//calling method
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("passed 0 as denominator");
		}
	}

}


throw:
```````
throw is a java reserved keyword, 

purpose: to throw an exception explicitly.

->throwing is nothging but creating an object 

 0 as denominator -> ArithmeticException can be thrown by jvm 
 
 
we are not throwing predefined exceptions using throw keyword.'
we are throwing our own exceptions using throw keyword.

syntax:

  try{
  throw new <exceptionclassname>();
  }
  catch(Exceptionclassname <referencevariable>){
    //user friendly message
  }
  

ecommerce website

  checking the product whether my product is valid or not 
  based on the product weight.
  
    if my product weight is greather than 100kgs then product is valid
	else InvalidProductException 
	
Test4.java:
```````````
package com.oracle.exceptions;

public class Test4 {
	
	
	public void checkProduct(int weight)
	{
		
		if(weight> 100)
		{
			System.out.println("product is valid");
		}
		else 
		{
			try {
			throw new InvalidProductException("check product weight");
			}
			catch(InvalidProductException ip)
			{
				System.out.println(ip);
			}
		}
	}
	
	
	//mainmethod
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
package com.oracle.exceptions;

public class InvalidProductException extends Throwable{

	
	public InvalidProductException(String message)
	{
		super(message);
	}
}


super :
``````
super is the java reserve keyword to refer parent class properties 
from the child class context when both are same.

 super at method level. -> referning super class method from child 
 class context.
 
 
super at constructor level.

constructor:

constructor is a special member method which is used to initialize 
the object. 


 without constructor:
 
 package com.oracle.constructors;

public class Test1 {

	int x;
	String y;
	public void assignValues()
	{
		x=100;
		y="rk";
	}
	public void display()
	{
		System.out.println(x + " " + y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.assignValues();
		obj.display();
		
	}
}
rules:

constructor name and classname must be same 
constructor should not return anything even void also.
constructor should not be static.

example:
`````````
package com.oracle.constructors;

public class Test1 {

	int x;
	String y;

	/*
	 * public void assignValues() { x=100; y="rk"; }
	 */
	public Test1()
	{
		x=100;
		y="rk";
	}
	
	public void display()
	{
		System.out.println(x + " " + y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		
		obj.display();
		
	}
}

types of constructors:

 default constructor
 parameterized constructor
 

super() -> used to invoke parent class default constructor 

super(...) -> used to invoke parent class parameterized constructor


system defined default constructor example:
````````````````````````````````````````````
package com.oracle.constructors;

public class Test2 {
	
	int x;
	String y;

	/*
	 * public Test2() { x=0; y=null; }
	 */
	public void display()
	{
		System.out.println(x + " "  +y);
	}
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		obj.display();
		
	}

}

collection framework :
```````````````````````


   int a = 100;
   
     int b = 200;
	 
	 1 crore values -> 1 variable 
	 
it is possible by declaring a variable as an array.

	int x[]={100,200,300,400,500};
	
	
	whenever we store the values inside an array, it is getting stored
	based on the index. 
	index value always starts from 0th location.
	length represents no.of elemens resides in that array
	
	x.length = 5
	
	if length is 5 , maximum index is 4
	
	if length is n, maximum index is (n-1) 
	beause index starts from 0th location.
	
	
sop(x[0])


 int x[]={100,200,300,400,"rama"};
 
 
using arrays, we can store only homogenious type of data, not 
heterogenious data. 

in arrays, for every operation we have to write the logic 
manually.

arrays are not following standard ds.

arrays size is fixed in nature ,we can't increase or decrease the 
size of an array at runtime. 


int x[]={100,200,300,400,500};
	
	

x[5]=600;

to overcome these drawbacks, we have one concept i.e 

Collection framework in java:
````````````````````````````

List interface:
`````````````````
->it allows both homogenious and heterogenious objects

->insertion order is preserved 

->duplicate objects are allowed

->null insertion is possible. 

 ArrayList
 LinkedList
 
  List l = new ArrayList();
  List l = new LinkedList();
  
 
from jdk1.5 version onwards, eventhough we are passing primitive type 
values internally it gets converted into object types. 
and viceversa.

  autoboxing 
  & autounboxing
  
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List
		
		List l = new ArrayList();
		
		l.add(Integer.valueOf(100));
		l.add(new String("rk"));
		l.add(Float.valueOf(2.3f));
		
		l.add(Integer.valueOf(100));
		
		l.add(null);
		
		l.add(67);
		
	
		for(int i=0;i<l.size();i++) {
			System.out.println(l.get(i));
		}
		
		System.out.println("==================");
		for(Object o:l)
		{
			System.out.println(o);
		}
		
	}

}
  
example:
``````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List
		
		List l = new ArrayList();
		
		//System.out.println(l.getClass().getName());
		
		
		for(int i=1;i<=10;i++)
		{
			l.add(i);
		}
		
		for(Object o: l)
		{
			//Parent to Child type casting -down casting
			Integer x = (Integer)o;
			
			if(x%2==0)
			{
				System.out.println(x);
			}
		}
		
	}

}

using generics :
``````````````````
1.explicit type casting is not required 
2.we will get compile time errors rather than runtime errors which are 
far better .

   package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List with generi
		
		List<Integer> l = new ArrayList<>();
		
		//System.out.println(l.getClass().getName());
		
		
		for(int i=1;i<=10;i++)
		{
			l.add(i);
		}
		
		//l.add("rama");
		
		for(Integer o: l)
		{
		  if(o%2==0)
			{
				System.out.println(o);
			}
		}
		
		
		
		
	}

}


package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object for List with generi
		
		List<Employee> l = new ArrayList<>();
		
		l.add(new Employee(100,"Rama"));
		l.add(new Employee(200,"sreeyansh"));
		
		l.add(new Employee(300,"amulya"));
		l.add(new Employee(400,"vedanth"));
		
		
		for(Employee e:l)
		{
			if(e.getEmpname().startsWith("a"))
			{
				System.out.println(e.getEmpid() + " " +e.getEmpname());
			}
		}
		
	}

}

if our frequet operation is insertin /deleteion /updation then 
we will go for LinkedList because internally it follows doublylinkedlist 
algorithm 

whereas if our frequent operation is retreival then we can go for 
ArrayList because ArrayList which implements from RandomAccess 


example:
``````````
package com.oracle.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test2 {

	
	public static void main(String[] args) {
		
		//create the object for List interface
		
		List l = new ArrayList();
		
		l.add(12);
		l.add(null);
		l.add(34);
		l.add(5);
		l.add("rama");
		l.add(true);
		
		System.out.println("before removing" + l);
		
		l.remove(5);
		
		System.out.println("after removing"  + l);
		
		l.remove(new Integer(34));
		
		System.out.println(l);
		
		System.out.println("size is : " + l.size());
		
		
		System.out.println("is empty ? " + l.isEmpty());
		
		System.out.println(l.contains("rama"));
	   
	    System.out.println("3rd index element is : " + l.get(3));
		
	    l.clear();
	    
	    System.out.println("size is after clearning: " + l.size());
		
	    System.out.println(l);
	}
}


Set
  HashSet
  LinkedHashSet
  
SortedSet
  TreeSet

Queue 


 Map 
 SortedMap
 
   HashMap,
   LinkedHashMap
   TreeMap

